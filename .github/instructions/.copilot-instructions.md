# GitHub Copilot Instructions for Lightdash Repository

## Project Context

**Lightdash** is an open-source business intelligence and analytics tool (Looker alternative) that integrates with dbt projects. It's a TypeScript monorepo using pnpm workspaces with a modern tech stack.

## Monorepo Structure

```
packages/
‚îú‚îÄ‚îÄ common/        ‚Üí Shared utilities, types, and business logic
‚îú‚îÄ‚îÄ backend/       ‚Üí Express.js API server with PostgreSQL
‚îú‚îÄ‚îÄ frontend/      ‚Üí React 19 web application with Vite
‚îú‚îÄ‚îÄ warehouses/    ‚Üí Data warehouse adapters (BigQuery, Snowflake, Postgres, etc.)
‚îú‚îÄ‚îÄ cli/           ‚Üí Command-line interface for dbt projects
‚îî‚îÄ‚îÄ e2e/           ‚Üí Cypress end-to-end tests
```

## Technology Stack

### Backend
- **Framework**: Express.js with session-based authentication
- **ORM**: Knex.js for database layer and migrations
- **Database**: PostgreSQL
- **API**: TSOA (generates OpenAPI specs from TypeScript decorators)
- **Authorization**: CASL-based permissions
- **Jobs**: node-cron scheduler for background tasks

### Frontend
- **Framework**: React 19 with TypeScript
- **Build Tool**: Vite
- **UI Library**: Mantine v8 with Emotion styling
- **Editor**: Monaco Editor for SQL editing
- **State Management**: TanStack Query for server state

### Build & Development
- **Package Manager**: pnpm (v9.15.5+) - **NEVER use npm or yarn**
- **Type Checking**: TypeScript with project references
- **Linting**: ESLint with Airbnb config (enforces `no-floating-promises`)
- **Pre-commit**: Husky + lint-staged
- **Testing**: Jest/Cypress for unit and E2E tests

## Development Workflow

### Package Management
- Always use `pnpm` - it's required for this monorepo
- Use `pnpm -F <package-name>` for package-specific commands
- Example: `pnpm -F backend lint`, `pnpm -F frontend typecheck`

### Code Quality Commands

**Linting:**
```bash
pnpm -F common lint
pnpm -F backend lint
pnpm -F frontend lint
```

**Type Checking:**
```bash
pnpm -F common typecheck
pnpm -F backend typecheck
pnpm -F frontend typecheck
```

**Testing:**
```bash
pnpm -F common test
pnpm -F backend test:dev:nowatch  # Only tests modified files
```

### Database Operations

**Create Migration:**
```bash
pnpm -F backend create-migration migration_name_with_underscores
```

**Run Migrations:**
```bash
pnpm -F backend migrate
```

**Rollback Last Migration:**
```bash
pnpm -F backend rollback-last
```

### API Updates

When modifying TSOA controllers in the backend, regenerate OpenAPI specs:
```bash
pnpm generate-api
```

## Code Style & Patterns

### TypeScript Best Practices

**1. Prefer Strict Object Shapes**
- ‚úÖ **Good**: `{ charts: Chart[] }` - explicitly an array (can be empty)
- ‚ùå **Avoid**: `{ charts?: Chart[] }` - ambiguous (missing or empty?)
- Start with required properties; make optional only when necessary

**2. Use Null for Absent Values**
- ‚úÖ **Good**: `{ createdBy: User | null }` - explicitly absent or present
- ‚ùå **Avoid**: `{ createdBy?: User }` - ambiguous presence
- Optional properties acceptable for: backwards compatibility, configuration defaults, API semantics

**3. No Duck Typing**
- Make parameter types intentional and explicit
- Avoid accepting "any" types with different behaviors
- Use union types or discriminated unions instead

**4. Exhaustive Type Checking**
- Use `assertUnreachable()` for switch statements on union types
- ‚úÖ **Good**: `default: return assertUnreachable(value, 'Unknown status');`
- ‚ùå **Avoid**: `default: throw new Error('Unknown status');`
- Import from: `import { assertUnreachable } from '@lightdash/common';`

### Naming & Structure
- Database migration files: use `snake_case` with underscores
- Controllers: use TSOA decorators for automatic API generation
- Background jobs: implement with node-cron scheduler
- Shared code: place in `packages/common` for reuse across packages

## TypeScript Project References

All packages are configured with TypeScript composite mode for proper IDE support:

- ‚úÖ All packages have `"composite": true` in tsconfig.json
- ‚úÖ Frontend and backend reference common via `"references"`
- ‚úÖ Common builds to: ESM (`dist/esm`), CJS (`dist/cjs`), Types (`dist/types`)
- ‚ö†Ô∏è Web workers importing from common: use `@lightdash/common/dist/esm/[module]`

## Security: Warehouse Credentials Protection

**CRITICAL**: When adding warehouse authentication fields, protect sensitive data!

**Location**: `packages/common/src/types/projects.ts`

### Sensitive Fields Array
```typescript
export const sensitiveCredentialsFieldNames = [
    'user',
    'password',
    'keyfileContents',
    'personalAccessToken',
    'privateKey',
    'privateKeyPass',
    'sshTunnelPrivateKey',
    'sslcert',
    'sslkey',
    'sslrootcert',
    'token',
    'refreshToken',
    'oauthClientId',
    'oauthClientSecret',
    // Add any new sensitive fields here!
] as const;
```

### When Adding New Auth Methods

1. **Identify sensitive fields**: passwords, tokens, keys, secrets, authentication identifiers
2. **Add to sensitiveCredentialsFieldNames**: ensures automatic stripping from API responses
3. **Test API responses**: verify sensitive data absent in `GET /api/v1/projects/{uuid}`
4. **Sensitive field examples**:
   - OAuth client secrets, refresh tokens, access tokens
   - Private keys, certificates
   - Database passwords, personal access tokens
5. **Potentially sensitive**: OAuth client IDs, usernames (use discretion)

### How It Works

- `CreateXxxCredentials` types: contain ALL fields (internal creation/updates)
- `XxxCredentials` types: `Omit<CreateXxxCredentials, SensitiveCredentialsFieldNames>` (API responses)
- `ProjectModel.get()`: automatically filters via sensitiveCredentialsFieldNames
- `ProjectModel.getWithSensitiveFields()`: unfiltered data for internal use only

## Testing & Debugging

### Frontend Testing
- Use puppeteer MCP for web app interaction
- Test credentials: `demo@lightdash.com` / `demo_password!`
- Test runner: Cypress for E2E tests

### Database Debugging
```bash
# View table schema
psql -c "\d cached_explores"

# Query projects
psql -c "SELECT project_uuid, name FROM projects LIMIT 5;"
```

### Database Reset
```bash
./scripts/reset-db.sh
# Resets DB, runs migrations, seeds dev data
```

### API Testing with Personal Access Token
```bash
# List spaces in project
curl -H "Authorization: ApiKey $LDPAT" "$SITE_URL/api/v1/projects/PROJECT_UUID/spaces"

# List organization projects
curl -H "Authorization: ApiKey $LDPAT" "$SITE_URL/api/v1/org/projects"

# Get root-level spaces (v2 API)
curl -H "Authorization: ApiKey $LDPAT" "$SITE_URL/api/v2/content?contentTypes=space&projectUuids=PROJECT_UUID&page=1&pageSize=25"
```

## Development Troubleshooting

- **dbt Issues**: Ensure Python 3 venv exists in repo root with `dbt-core` and `dbt-postgres` installed
- **Dev Server**: Assume it's always running during development
- **TypeScript Errors**: Run `pnpm -F <package> typecheck` to verify types
- **API Changes**: Remember to run `pnpm generate-api` after TSOA controller modifications

## Key Configuration Files

- `/tsconfig.json` - TypeScript project references configuration
- `/pnpm-workspace.yaml` - Monorepo workspace definition
- `/.eslintrc.js` - Global ESLint rules (Airbnb + custom)
- `/package.json` - Root scripts and dependency management
- `.env.development.local` - Local environment variables

## Project Milestones & Labeling

- **Customer Support Issues**: Tracked under milestone 184
- **Bug Label**: üêõ bug - Use for bug reports and fixes

## Common Patterns & Tips

- Package-specific commands are faster than root commands for linting/testing
- TSOA decorators generate API endpoints - modify them carefully
- Authorization uses CASL - check patterns in existing controllers
- Mantine v8 components have built-in TypeScript support
- TanStack Query handles caching and server state automatically
- ESLint enforces no-floating-promises - always await async functions
